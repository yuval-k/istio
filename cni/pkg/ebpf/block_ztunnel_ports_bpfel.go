// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64 || amd64p32 || arm || arm64 || loong64 || mips64le || mips64p32le || mipsle || ppc64le || riscv64

package ebpf

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

// loadBlock_ztunnel_ports returns the embedded CollectionSpec for block_ztunnel_ports.
func loadBlock_ztunnel_ports() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_Block_ztunnel_portsBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load block_ztunnel_ports: %w", err)
	}

	return spec, err
}

// loadBlock_ztunnel_portsObjects loads block_ztunnel_ports and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*block_ztunnel_portsObjects
//	*block_ztunnel_portsPrograms
//	*block_ztunnel_portsMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadBlock_ztunnel_portsObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadBlock_ztunnel_ports()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// block_ztunnel_portsSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type block_ztunnel_portsSpecs struct {
	block_ztunnel_portsProgramSpecs
	block_ztunnel_portsMapSpecs
}

// block_ztunnel_portsSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type block_ztunnel_portsProgramSpecs struct {
	BindV4Prog *ebpf.ProgramSpec `ebpf:"bind_v4_prog"`
	BindV6Prog *ebpf.ProgramSpec `ebpf:"bind_v6_prog"`
}

// block_ztunnel_portsMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type block_ztunnel_portsMapSpecs struct {
	ShouldEnforceBind *ebpf.MapSpec `ebpf:"should_enforce_bind"`
}

// block_ztunnel_portsObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadBlock_ztunnel_portsObjects or ebpf.CollectionSpec.LoadAndAssign.
type block_ztunnel_portsObjects struct {
	block_ztunnel_portsPrograms
	block_ztunnel_portsMaps
}

func (o *block_ztunnel_portsObjects) Close() error {
	return _Block_ztunnel_portsClose(
		&o.block_ztunnel_portsPrograms,
		&o.block_ztunnel_portsMaps,
	)
}

// block_ztunnel_portsMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadBlock_ztunnel_portsObjects or ebpf.CollectionSpec.LoadAndAssign.
type block_ztunnel_portsMaps struct {
	ShouldEnforceBind *ebpf.Map `ebpf:"should_enforce_bind"`
}

func (m *block_ztunnel_portsMaps) Close() error {
	return _Block_ztunnel_portsClose(
		m.ShouldEnforceBind,
	)
}

// block_ztunnel_portsPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadBlock_ztunnel_portsObjects or ebpf.CollectionSpec.LoadAndAssign.
type block_ztunnel_portsPrograms struct {
	BindV4Prog *ebpf.Program `ebpf:"bind_v4_prog"`
	BindV6Prog *ebpf.Program `ebpf:"bind_v6_prog"`
}

func (p *block_ztunnel_portsPrograms) Close() error {
	return _Block_ztunnel_portsClose(
		p.BindV4Prog,
		p.BindV6Prog,
	)
}

func _Block_ztunnel_portsClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed block_ztunnel_ports_bpfel.o
var _Block_ztunnel_portsBytes []byte
